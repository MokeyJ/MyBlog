## Cache-control

网页的缓存是由HTTP消息头中的“Cache-control”来控制的，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。

##### 表 1. 常用 cache-directive 值

|Cache-directive|	说明|
|---|---|
public | 所有内容都将被缓存(客户端和代理服务器都可缓存)
private | 内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)
no-cache | 必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。
no-store | 所有内容都不会被缓存到缓存或 Internet 临时文件中
must-revalidation/proxy-revalidation | 如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证
max-age=xxx (xxx is numeric) | 缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高

##### 表 2. 对 cache-directive 值的浏览器响应

表 2 表明在不同的情形下，浏览器是将请求重新发送到服务器还是使用缓存的内容。


|Cache-directive|	打开一个新的浏览器窗口|在原窗口中单击 Enter 按钮|刷新|	单击 Back 按钮|
|---|---|---|---|---|
|public | 浏览器呈现来自缓存的页面 |浏览器呈现来自缓存的页面 |浏览器重新发送请求到服务器 | 浏览器呈现来自缓存的页面
|private| 浏览器重新发送请求到服务器| 第一次，浏览器重新发送请求到服务器；此后，浏览器呈现来自缓存的页面| 浏览器重新发送请求到服务器|浏览器呈现来自缓存的页面
|no-cache/no-store|浏览器重新发送请求到服务器|浏览器重新发送请求到服务器|浏览器重新发送请求到服务器|浏览器重新发送请求到服务器
|must-revalidation/proxy-revalidation|浏览器重新发送请求到服务器|第一次，浏览器重新发送请求到服务器；此后，浏览器呈现来自缓存的页面|浏览器重新发送请求到服务器|浏览器呈现来自缓存的页面
|max-age=xxx (xxx is numeric)|在 xxx 秒后，浏览器重新发送请求到服务器|在 xxx 秒后，浏览器重新发送请求到服务器|浏览器重新发送请求到服务器|在 xxx 秒后，浏览器重新发送请求到服务器

Cache-Control是关于浏览器缓存的最重要的设置，因为它覆盖其他设置，比如 Expires 和 Last-Modified。另外，由于浏览器的行为基本相同，这个属性是处理跨浏览器缓存问题的最有效的方法。

（注意：cache-control max-age 和 s-maxage 将覆盖 Expires 头部。）

#### 关键结论
最后, 概括下关键的结论:
