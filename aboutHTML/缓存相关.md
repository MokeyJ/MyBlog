## Cache-control

网页的缓存是由HTTP消息头中的“Cache-control”来控制的，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。

##### 表 1. 常用 cache-directive 值

|Cache-directive|	说明|
|---|---|
public | 所有内容都将被缓存(客户端和代理服务器都可缓存)
private | 内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)
no-cache | 必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。
no-store | 所有内容都不会被缓存到缓存或 Internet 临时文件中
must-revalidation/proxy-revalidation | 如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证
max-age=xxx (xxx is numeric) | 缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高
|only-if-cached|表明如果缓存存在，只使用缓存，无论原始服务器数据是否有更新。|

##### 表 2. 对 cache-directive 值的浏览器响应

表 2 表明在不同的情形下，浏览器是将请求重新发送到服务器还是使用缓存的内容。


|Cache-directive|	打开一个新的浏览器窗口|在原窗口中单击 Enter 按钮|刷新|	单击 Back 按钮|
|---|---|---|---|---|
|public | 浏览器呈现来自缓存的页面 |浏览器呈现来自缓存的页面 |浏览器重新发送请求到服务器 | 浏览器呈现来自缓存的页面
|private| 浏览器重新发送请求到服务器| 第一次，浏览器重新发送请求到服务器；此后，浏览器呈现来自缓存的页面| 浏览器重新发送请求到服务器|浏览器呈现来自缓存的页面
|no-cache/no-store|浏览器重新发送请求到服务器|浏览器重新发送请求到服务器|浏览器重新发送请求到服务器|浏览器重新发送请求到服务器
|must-revalidation/proxy-revalidation|浏览器重新发送请求到服务器|第一次，浏览器重新发送请求到服务器；此后，浏览器呈现来自缓存的页面|浏览器重新发送请求到服务器|浏览器呈现来自缓存的页面
|max-age=xxx (xxx is numeric)|在 xxx 秒后，浏览器重新发送请求到服务器|在 xxx 秒后，浏览器重新发送请求到服务器|浏览器重新发送请求到服务器|在 xxx 秒后，浏览器重新发送请求到服务器

Cache-Control是关于浏览器缓存的最重要的设置，因为它覆盖其他设置，比如 Expires 和 Last-Modified。另外，由于浏览器的行为基本相同，这个属性是处理跨浏览器缓存问题的最有效的方法。

（注意：cache-control max-age 和 s-maxage 将覆盖 Expires 头部。）

#### 关键结论

最后, 概括下关键的结论:

|||
|---|---|
|打开新窗口|如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器,例如：Cache-control: max-age=5 表示当访问此网页后的5秒内不会去再次访问服务器.|
|在地址栏回车|如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。|
|按后退按扭|如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问.|
|按刷新按扭|	无论为何值,都会重复访问.|

